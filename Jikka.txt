-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/kmyk/Jikka</a>
@package Jikka
@version 5.0.1.0


-- | <a>Alpha</a> provides a monad to run alpha-conversion. This monad has
--   only a feature to make unique numbers.
module Jikka.Common.Alpha
class Monad m => MonadAlpha m
nextCounter :: MonadAlpha m => m Int
type Alpha = StateT Int (Either String)
runAlpha :: Int -> Alpha a -> Either String (a, Int)
evalAlpha :: Int -> Alpha a -> Either String a
evalAlpha' :: Alpha a -> Either String a
instance GHC.Base.Monad m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.State.Strict.StateT GHC.Types.Int m)

module Jikka.Deserializer.Read
run :: Read program => FilePath -> Text -> Either String program


-- | <a>Expr</a> module has the basic data types for C++ language. The data
--   types are intended to use for the code generation.
module Jikka.Language.CPlusPlus.Expr
newtype VarName
VarName :: String -> VarName
[unVarName] :: VarName -> String
newtype FunName
FunName :: String -> FunName
[unFunName] :: FunName -> String
data Type
TyAuto :: Type
TyVoid :: Type
TyBool :: Type
TyInt32 :: Type
TyInt64 :: Type
TyTuple :: [Type] -> Type
TyVector :: Type -> Type
TyArray :: Type -> Integer -> Type
data Literal
LitInt32 :: Integer -> Literal
LitInt64 :: Integer -> Literal
LitBool :: Bool -> Literal
data Function
Callable :: Expr -> Function
Function :: FunName -> [Type] -> Function
Method :: Expr -> FunName -> Function
data UnaryOp
IntNop :: UnaryOp
Negate :: UnaryOp
BitNot :: UnaryOp
Not :: UnaryOp
data BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Mul :: BinaryOp
Div :: BinaryOp
Mod :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
BitLeftShift :: BinaryOp
BitRightShift :: BinaryOp
And :: BinaryOp
Or :: BinaryOp
LessThan :: BinaryOp
LessEqual :: BinaryOp
GreaterThan :: BinaryOp
GreaterEqual :: BinaryOp
Equal :: BinaryOp
NotEqual :: BinaryOp
data AssignOp
SimpleAssign :: AssignOp
AddAssign :: AssignOp
SubAssign :: AssignOp
MulAssign :: AssignOp
DivAssign :: AssignOp
ModAssign :: AssignOp
BitLeftShiftAssign :: AssignOp
BitRightShiftAssign :: AssignOp
BitAndAssign :: AssignOp
BitOrAssign :: AssignOp
BitXorAssign :: AssignOp
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr
UnOp :: UnaryOp -> Expr -> Expr
BinOp :: BinaryOp -> Expr -> Expr -> Expr
Cond :: Expr -> Expr -> Expr -> Expr
Lam :: [(Type, VarName)] -> Type -> [Statement] -> Expr
Call :: Function -> [Expr] -> Expr
VecExt :: Type -> [Expr] -> Expr
At :: Expr -> Expr -> Expr
Cast :: Type -> Expr -> Expr
data LeftExpr
LeftVar :: VarName -> LeftExpr
LeftAt :: LeftExpr -> Expr -> LeftExpr
data AssignExpr
AssignExpr :: AssignOp -> LeftExpr -> Expr -> AssignExpr
AssignIncr :: LeftExpr -> AssignExpr
AssignDecr :: LeftExpr -> AssignExpr
data Statement
ExprStatement :: Expr -> Statement
Block :: [Statement] -> Statement
If :: Expr -> [Statement] -> Maybe [Statement] -> Statement
For :: Type -> VarName -> Expr -> Expr -> AssignExpr -> [Statement] -> Statement
ForEach :: Type -> VarName -> Expr -> [Statement] -> Statement
While :: Expr -> [Statement] -> Statement
Declare :: Type -> VarName -> Maybe Expr -> Statement
Assign :: AssignExpr -> Statement
Assert :: Expr -> Statement
Return :: Expr -> Statement
data ToplevelStatement
VarDef :: Type -> VarName -> Expr -> ToplevelStatement
FunDef :: Type -> VarName -> [(Type, VarName)] -> [Statement] -> ToplevelStatement
newtype Program
Program :: [ToplevelStatement] -> Program
[decls] :: Program -> [ToplevelStatement]
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Program
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Program
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Program
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Program
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.ToplevelStatement
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.ToplevelStatement
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.ToplevelStatement
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.ToplevelStatement
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Function
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Function
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Function
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Function
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Expr
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Expr
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Expr
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Expr
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.LeftExpr
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.LeftExpr
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.LeftExpr
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.LeftExpr
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.AssignExpr
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.AssignExpr
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.AssignExpr
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.AssignExpr
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Statement
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Statement
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Statement
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Statement
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.AssignOp
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.AssignOp
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.AssignOp
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.AssignOp
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.BinaryOp
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.BinaryOp
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.BinaryOp
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.BinaryOp
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.UnaryOp
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.UnaryOp
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.UnaryOp
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.UnaryOp
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Literal
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Literal
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Literal
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Literal
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.Type
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.Type
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.Type
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.Type
instance Data.String.IsString Jikka.Language.CPlusPlus.Expr.FunName
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.FunName
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.FunName
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.FunName
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.FunName
instance Data.String.IsString Jikka.Language.CPlusPlus.Expr.VarName
instance GHC.Read.Read Jikka.Language.CPlusPlus.Expr.VarName
instance GHC.Show.Show Jikka.Language.CPlusPlus.Expr.VarName
instance GHC.Classes.Ord Jikka.Language.CPlusPlus.Expr.VarName
instance GHC.Classes.Eq Jikka.Language.CPlusPlus.Expr.VarName

module Jikka.Language.Common.Name
type Name = String
newtype VarName
VarName :: Name -> VarName
unVarName :: VarName -> Name
newtype FunName
FunName :: Name -> FunName
unFunName :: FunName -> Name
newtype TypeName
TypeName :: Name -> TypeName
unTypeName :: TypeName -> Name
instance Data.String.IsString Jikka.Language.Common.Name.TypeName
instance GHC.Read.Read Jikka.Language.Common.Name.TypeName
instance GHC.Show.Show Jikka.Language.Common.Name.TypeName
instance GHC.Classes.Ord Jikka.Language.Common.Name.TypeName
instance GHC.Classes.Eq Jikka.Language.Common.Name.TypeName
instance Data.String.IsString Jikka.Language.Common.Name.FunName
instance GHC.Read.Read Jikka.Language.Common.Name.FunName
instance GHC.Show.Show Jikka.Language.Common.Name.FunName
instance GHC.Classes.Ord Jikka.Language.Common.Name.FunName
instance GHC.Classes.Eq Jikka.Language.Common.Name.FunName
instance Data.String.IsString Jikka.Language.Common.Name.VarName
instance GHC.Read.Read Jikka.Language.Common.Name.VarName
instance GHC.Show.Show Jikka.Language.Common.Name.VarName
instance GHC.Classes.Ord Jikka.Language.Common.Name.VarName
instance GHC.Classes.Eq Jikka.Language.Common.Name.VarName

module Jikka.Language.Common.Pos
data Pos
Pos :: !Int -> !Int -> Pos
[line] :: Pos -> !Int
[column] :: Pos -> !Int
data WithPos a
WithPos :: !Pos -> !a -> WithPos a
[pos] :: WithPos a -> !Pos
[value] :: WithPos a -> !a
withPos :: WithPos a -> b -> WithPos b
prettyPos :: Pos -> String
instance GHC.Base.Functor Jikka.Language.Common.Pos.WithPos
instance GHC.Read.Read a => GHC.Read.Read (Jikka.Language.Common.Pos.WithPos a)
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Language.Common.Pos.WithPos a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Language.Common.Pos.WithPos a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Language.Common.Pos.WithPos a)
instance GHC.Read.Read Jikka.Language.Common.Pos.Pos
instance GHC.Show.Show Jikka.Language.Common.Pos.Pos
instance GHC.Classes.Ord Jikka.Language.Common.Pos.Pos
instance GHC.Classes.Eq Jikka.Language.Common.Pos.Pos

module Jikka.Deserializer.ShuntingYard
run :: forall op expr. (op -> Either String BinOpInfo) -> (WithPos op -> WithPos expr -> WithPos expr -> WithPos expr) -> (WithPos expr, [(WithPos op, WithPos expr)]) -> Either String (WithPos expr)
type Prec = Int
data Fixity
Leftfix :: Fixity
Rightfix :: Fixity
Nonfix :: Fixity
data BinOpInfo
BinOpInfo :: Fixity -> Prec -> BinOpInfo
instance GHC.Read.Read Jikka.Deserializer.ShuntingYard.BinOpInfo
instance GHC.Show.Show Jikka.Deserializer.ShuntingYard.BinOpInfo
instance GHC.Classes.Ord Jikka.Deserializer.ShuntingYard.BinOpInfo
instance GHC.Classes.Eq Jikka.Deserializer.ShuntingYard.BinOpInfo
instance GHC.Read.Read Jikka.Deserializer.ShuntingYard.Fixity
instance GHC.Show.Show Jikka.Deserializer.ShuntingYard.Fixity
instance GHC.Enum.Bounded Jikka.Deserializer.ShuntingYard.Fixity
instance GHC.Enum.Enum Jikka.Deserializer.ShuntingYard.Fixity
instance GHC.Classes.Ord Jikka.Deserializer.ShuntingYard.Fixity
instance GHC.Classes.Eq Jikka.Deserializer.ShuntingYard.Fixity

module Jikka.Deserializer.OffsideRule
insertIndentTokens :: forall a. IndentSetting a -> [WithPos a] -> Either String [WithPos a]
data IndentSetting a
IndentSetting :: a -> a -> Int -> Int -> (a -> Bool) -> (a -> Bool) -> Bool -> IndentSetting a
[indentToken] :: IndentSetting a -> a
[dedentToken] :: IndentSetting a -> a
[initialLine] :: IndentSetting a -> Int
[initialColumn] :: IndentSetting a -> Int
[isOpenParenToken] :: IndentSetting a -> a -> Bool
[isCloseParenToken] :: IndentSetting a -> a -> Bool
[allowNoMatchingDedent] :: IndentSetting a -> Bool

module Jikka.Deserializer.Python.Lexer
data Token
None :: Token
Int :: Integer -> Token
Bool :: Bool -> Token
Def :: Token
If :: Token
Elif :: Token
Else :: Token
For :: Token
In :: Token
Assert :: Token
Return :: Token
Import :: Token
From :: Token
Arrow :: Token
Colon :: Token
Comma :: Token
Dot :: Token
Equal :: Token
Underscore :: Token
OpenBrace :: Token
OpenBracket :: Token
OpenParen :: Token
CloseBrace :: Token
CloseBracket :: Token
CloseParen :: Token
SingleQuote :: Token
DoubleQuote :: Token
Ident :: String -> Token
Op :: String -> Token
Newline :: Token
Indent :: Token
Dedent :: Token
run :: String -> Either String [WithPos Token]
instance GHC.Read.Read Jikka.Deserializer.Python.Lexer.Token
instance GHC.Show.Show Jikka.Deserializer.Python.Lexer.Token
instance GHC.Classes.Ord Jikka.Deserializer.Python.Lexer.Token
instance GHC.Classes.Eq Jikka.Deserializer.Python.Lexer.Token
instance GHC.Show.Show Jikka.Deserializer.Python.Lexer.AlexPosn
instance GHC.Classes.Eq Jikka.Deserializer.Python.Lexer.AlexPosn
instance GHC.Base.Functor Jikka.Deserializer.Python.Lexer.Alex
instance GHC.Base.Applicative Jikka.Deserializer.Python.Lexer.Alex
instance GHC.Base.Monad Jikka.Deserializer.Python.Lexer.Alex


-- | <a>Expr</a> module has the basic data types for our core language.
--   They are similar to the GHC Core language.
module Jikka.Language.Core.Expr

-- | <a>Type</a> represents the types of our core language. This is similar
--   to the <a>Type</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>type-type</a>.
--   
--   &lt;math&gt;
data Type
IntTy :: Type
BoolTy :: Type
ListTy :: Type -> Type

-- | The functions are not curried.
FunTy :: [Type] -> Type -> Type
data Builtin
Negate :: Builtin
Plus :: Builtin
Minus :: Builtin
Mult :: Builtin
FloorDiv :: Builtin
FloorMod :: Builtin
CeilDiv :: Builtin
CeilMod :: Builtin
Pow :: Builtin
NatInd :: Type -> Builtin
Abs :: Builtin
Gcd :: Builtin
Lcm :: Builtin
Min :: Builtin
Max :: Builtin
Not :: Builtin
And :: Builtin
Or :: Builtin
Implies :: Builtin
If :: Type -> Builtin
BitNot :: Builtin
BitAnd :: Builtin
BitOr :: Builtin
BitXor :: Builtin
BitLeftShift :: Builtin
BitRightShift :: Builtin
Inv :: Builtin
PowMod :: Builtin
Len :: Type -> Builtin
Tabulate :: Type -> Builtin
Map :: Type -> Type -> Builtin
At :: Type -> Builtin
Sum :: Builtin
Product :: Builtin
Min1 :: Builtin
Max1 :: Builtin
ArgMin :: Builtin
ArgMax :: Builtin
All :: Builtin
Any :: Builtin
Sorted :: Type -> Builtin
List :: Type -> Builtin
Reversed :: Type -> Builtin
Range1 :: Builtin
Range2 :: Builtin
Range3 :: Builtin
LessThan :: Builtin
LessEqual :: Builtin
GreaterThan :: Builtin
GreaterEqual :: Builtin
Equal :: Type -> Builtin
NotEqual :: Type -> Builtin
Fact :: Builtin
Choose :: Builtin
Permute :: Builtin
MultiChoose :: Builtin
data Literal
LitBuiltin :: Builtin -> Literal
LitInt :: Integer -> Literal
LitBool :: Bool -> Literal

-- | <a>Expr</a> represents the exprs of our core language. This is similar
--   to the <a>Expr</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>core-syn-type</a>.
--   
--   &lt;math&gt;
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr

-- | The functions are not curried.
App :: Expr -> [Expr] -> Expr

-- | The lambdas are also not curried.
Lam :: [(VarName, Type)] -> Expr -> Expr

-- | This "let" is not recursive.
Let :: VarName -> Type -> Expr -> Expr -> Expr
pattern Fun1Ty :: Type -> Type
pattern Fun2Ty :: Type -> Type
pattern Fun3Ty :: Type -> Type
pattern FunLTy :: Type -> Type
pattern Lit0 :: Expr
pattern Lit1 :: Expr
pattern Lit2 :: Expr
pattern LitMinus1 :: Expr
pattern LitTrue :: Expr
pattern LitFalse :: Expr
pattern Builtin :: Builtin -> Expr
pattern AppBuiltin :: Builtin -> [Expr] -> Expr
pattern Lam1 :: VarName -> Type -> Expr -> Expr
pattern Lam2 :: VarName -> Type -> VarName -> Type -> Expr -> Expr
pattern Lam3 :: VarName -> Type -> VarName -> Type -> VarName -> Type -> Expr -> Expr
pattern LamId :: VarName -> Type -> Expr
data RecKind
NonRec :: RecKind
Rec :: RecKind

-- | <a>ToplevelExpr</a> is the toplevel exprs. In our core, "let rec" is
--   allowed only on the toplevel.
data ToplevelExpr
ResultExpr :: Expr -> ToplevelExpr
ToplevelLet :: RecKind -> VarName -> [(VarName, Type)] -> Type -> Expr -> ToplevelExpr -> ToplevelExpr
type Program = ToplevelExpr
instance GHC.Read.Read Jikka.Language.Core.Expr.ToplevelExpr
instance GHC.Show.Show Jikka.Language.Core.Expr.ToplevelExpr
instance GHC.Classes.Ord Jikka.Language.Core.Expr.ToplevelExpr
instance GHC.Classes.Eq Jikka.Language.Core.Expr.ToplevelExpr
instance GHC.Read.Read Jikka.Language.Core.Expr.RecKind
instance GHC.Show.Show Jikka.Language.Core.Expr.RecKind
instance GHC.Classes.Ord Jikka.Language.Core.Expr.RecKind
instance GHC.Classes.Eq Jikka.Language.Core.Expr.RecKind
instance GHC.Read.Read Jikka.Language.Core.Expr.Expr
instance GHC.Show.Show Jikka.Language.Core.Expr.Expr
instance GHC.Classes.Ord Jikka.Language.Core.Expr.Expr
instance GHC.Classes.Eq Jikka.Language.Core.Expr.Expr
instance GHC.Read.Read Jikka.Language.Core.Expr.Literal
instance GHC.Show.Show Jikka.Language.Core.Expr.Literal
instance GHC.Classes.Ord Jikka.Language.Core.Expr.Literal
instance GHC.Classes.Eq Jikka.Language.Core.Expr.Literal
instance GHC.Read.Read Jikka.Language.Core.Expr.Builtin
instance GHC.Show.Show Jikka.Language.Core.Expr.Builtin
instance GHC.Classes.Ord Jikka.Language.Core.Expr.Builtin
instance GHC.Classes.Eq Jikka.Language.Core.Expr.Builtin
instance GHC.Read.Read Jikka.Language.Core.Expr.Type
instance GHC.Show.Show Jikka.Language.Core.Expr.Type
instance GHC.Classes.Ord Jikka.Language.Core.Expr.Type
instance GHC.Classes.Eq Jikka.Language.Core.Expr.Type


-- | <a>BuiltinPatterns</a> provides pattern synonyms for applications of
--   <a>Builtin</a> functions. For example, provide a pattern <tt>Sum'
--   e</tt> which is interpreted as <tt>AppBuiltin Sum [e]</tt>, or the
--   same thing, <tt>App (Lit (LitBuiltin Sum)) [e]</tt>.
module Jikka.Language.Core.BuiltinPatterns
pattern Negate' :: Expr -> Expr
pattern Plus' :: Expr -> Expr -> Expr
pattern Minus' :: Expr -> Expr -> Expr
pattern Mult' :: Expr -> Expr -> Expr
pattern FloorDiv' :: Expr -> Expr -> Expr
pattern FloorMod' :: Expr -> Expr -> Expr
pattern CeilDiv' :: Expr -> Expr -> Expr
pattern CeilMod' :: Expr -> Expr -> Expr
pattern Pow' :: Expr -> Expr -> Expr
pattern NatInd' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Abs' :: Expr -> Expr
pattern Gcd' :: Expr -> Expr -> Expr
pattern Lcm' :: Expr -> Expr -> Expr
pattern Min' :: Expr -> Expr -> Expr
pattern Max' :: Expr -> Expr -> Expr
pattern Not' :: Expr -> Expr
pattern And' :: Expr -> Expr -> Expr
pattern Or' :: Expr -> Expr -> Expr
pattern Implies' :: Expr -> Expr -> Expr
pattern If' :: Type -> Expr -> Expr -> Expr -> Expr
pattern BitNot' :: Expr -> Expr
pattern BitAnd' :: Expr -> Expr -> Expr
pattern BitOr' :: Expr -> Expr -> Expr
pattern BitXor' :: Expr -> Expr -> Expr
pattern BitLeftShift' :: Expr -> Expr -> Expr
pattern BitRightShift' :: Expr -> Expr -> Expr
pattern Inv' :: Expr -> Expr -> Expr
pattern PowMod' :: Expr -> Expr -> Expr -> Expr
pattern Len' :: Type -> Expr -> Expr
pattern Tabulate' :: Type -> Expr -> Expr -> Expr
pattern Map' :: Type -> Type -> Expr -> Expr -> Expr
pattern At' :: Type -> Expr -> Expr -> Expr
pattern Sum' :: Expr -> Expr
pattern Product' :: Expr -> Expr
pattern Min1' :: Expr -> Expr
pattern Max1' :: Expr -> Expr
pattern ArgMin' :: Expr -> Expr
pattern ArgMax' :: Expr -> Expr
pattern All' :: Expr -> Expr
pattern Any' :: Expr -> Expr
pattern Sorted' :: Type -> Expr -> Expr
pattern List' :: Type -> Expr -> Expr
pattern Reversed' :: Type -> Expr -> Expr
pattern Range1' :: Expr -> Expr
pattern Range2' :: Expr -> Expr -> Expr
pattern Range3' :: Expr -> Expr -> Expr -> Expr
pattern LessThan' :: Expr -> Expr -> Expr
pattern LessEqual' :: Expr -> Expr -> Expr
pattern GreaterThan' :: Expr -> Expr -> Expr
pattern GreaterEqual' :: Expr -> Expr -> Expr
pattern Equal' :: Type -> Expr -> Expr -> Expr
pattern NotEqual' :: Type -> Expr -> Expr -> Expr
pattern Fact' :: Expr -> Expr
pattern Choose' :: Expr -> Expr -> Expr
pattern Permute' :: Expr -> Expr -> Expr
pattern MultiChoose' :: Expr -> Expr -> Expr


-- | <a>Lint</a> module checks the invariants of data types. Mainly, this
--   checks types of <a>Expr</a>.
module Jikka.Language.Core.Lint
builtinToType :: Builtin -> Type
literalToType :: Literal -> Type
type TypeEnv = [(VarName, Type)]

-- | <a>typecheckExpr</a> checks that the given <a>Expr</a> has the correct
--   types.
typecheckExpr :: MonadError String m => TypeEnv -> Expr -> m Type
typecheckToplevelExpr :: MonadError String m => TypeEnv -> ToplevelExpr -> m Type
typecheckProgram :: MonadError String m => Program -> m Type
typecheckProgram' :: MonadError String m => Program -> m Program


-- | <a>Core</a> evaluates exprs to values. Also this recognizes users'
--   inputs at once.
--   
--   The implementation assumes that all variable names don't conflict even
--   when their scopes are distinct. Also this assumes that exprs allow the
--   eager evaluation. Please use <a>MakeEager</a> if needed.
module Jikka.Evaluator.Core
run :: Program -> ExceptT String IO Value
run' :: [Token] -> Program -> Either String Value
data Value
ValInt :: Integer -> Value
ValBool :: Bool -> Value
ValList :: Array Int Value -> Value
ValBuiltin :: Builtin -> Value
ValLambda :: Env -> [(VarName, Type)] -> Expr -> Value
newtype Token
Token :: String -> Token
[unToken] :: Token -> String
tokenize :: String -> [Token]
instance GHC.Read.Read Jikka.Evaluator.Core.Value
instance GHC.Show.Show Jikka.Evaluator.Core.Value
instance GHC.Classes.Ord Jikka.Evaluator.Core.Value
instance GHC.Classes.Eq Jikka.Evaluator.Core.Value
instance GHC.Read.Read Jikka.Evaluator.Core.Token
instance GHC.Show.Show Jikka.Evaluator.Core.Token
instance GHC.Classes.Ord Jikka.Evaluator.Core.Token
instance GHC.Classes.Eq Jikka.Evaluator.Core.Token


-- | <a>MakeEager</a> wraps some exprs with lambda redundant things from
--   AST. Specifically, this converts <tt>if p then a else b</tt> to
--   <tt>(if p then (lambda x. a) else (lambda x. b)) 0</tt>.
module Jikka.Converter.Core.MakeEager
run :: Program -> Either String Program


-- | <a>Alpha</a> renames variables in exprs to avoid name conflictions,
--   even if the scopes of two variables are distinct.
module Jikka.Converter.Core.Alpha
gensym :: MonadAlpha m => m VarName
rename :: MonadAlpha m => VarName -> m VarName
rename' :: VarName -> Int -> VarName
runExpr :: (MonadAlpha m, MonadError String m) => [(VarName, VarName)] -> Expr -> m Expr
runToplevelExpr :: (MonadAlpha m, MonadError String m) => [(VarName, VarName)] -> ToplevelExpr -> m ToplevelExpr
runProgram :: (MonadAlpha m, MonadError String m) => Program -> m Program
run' :: Program -> Int -> Either String (Program, Int)
run :: Program -> Either String Program


-- | <a>ValueApps</a> removes complicated exprs in lambda applications.
--   This removes <a>App</a>, <a>Lam</a> and <a>Let</a> from the callee and
--   arguments of <a>App</a>, and removes <a>Let</a> from the bound value
--   of <a>Let</a>.
--   
--   TODO: rename to a better name
module Jikka.Converter.Core.ValueApps
run :: Program -> Either String Program


module Jikka.Language.Core.Vars

-- | <a>isFreeVar</a> checks if the given variable occurs in the tiven
--   expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam1 (VarName "y") IntTy (Var (VarName "x"))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam1 (VarName "x") IntTy (Var (VarName "x"))
--   False
--   </pre>
isFreeVar :: VarName -> Expr -> Bool

-- | <a>isUnusedVar</a> is the negation of <a>isFreeVar</a>.
--   
--   TODO: rename to <tt>isNonFreeVar</tt>?
isUnusedVar :: VarName -> Expr -> Bool

-- | <a>isFreeVarOrScopedVar</a> checks if the given variable occurs in the
--   tiven expr. This ignores contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVarOrScopedVar` Lam1 (VarName "x") IntTy (Var (VarName "y"))
--   True
--   </pre>
isFreeVarOrScopedVar :: VarName -> Expr -> Bool

-- | <a>findFreshVar</a> generates a variable which isn't free in the given
--   expr. The return variable name may conflict if you ignores the
--   context.
findFreshVar :: Expr -> VarName

-- | TODO: make a function to list free/scoped vars and use it to optimize
--   the time complexity.
findFreshVar' :: [Expr] -> VarName
getAnonymousVar :: Int -> VarName


module Jikka.Language.Core.Beta

-- | <a>substitute</a> replaces the occrences of the given variable with
--   the given expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; substitute (VarName "x") (Lit (LitInt 0)) (Lam1 (VarName "y") IntTy (Var (VarName "x")))
--   Lam [(VarName "y",IntTy)] (Lit (LitInt 0))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; substitute (VarName "x") (Lit (LitInt 0)) (Lam1 (VarName "x") IntTy (Var (VarName "x")))
--   Lam [(VarName "x",IntTy)] (Var (VarName "x"))
--   </pre>
substitute :: VarName -> Expr -> Expr -> Expr
substitute' :: [VarName] -> VarName -> Expr -> Expr -> Expr


-- | <a>FromCore</a> converts exprs of our core language to exprs of C++.
module Jikka.Converter.CPlusPlus.FromCore
run :: Program -> Either String Program


-- | <a>StrengthReduction</a> replaces strong functions in exprs with
--   weaker functions. For example, this replace <tt>abs x</tt> with
--   <tt>max x (- x)</tt>.
module Jikka.Converter.Core.StrengthReduction
run :: Program -> Either String Program


-- | <a>RemoveUnusedVars</a> remove unused variables from exprs.
module Jikka.Converter.Core.RemoveUnusedVars
run :: Program -> Either String Program


-- | <a>Optimize</a> is a module to combine other all optimizers.
module Jikka.Converter.Core.Optimize
run :: Program -> Either String Program

module Jikka.Language.Python.Parsed.Expr
type Type' = WithPos Type
type Expr' = WithPos Expr
type Sentence' = WithPos Sentence
type ToplevelDecl' = WithPos ToplevelDecl
data Type
TyInt :: Type
TyNat :: Type
TyInterval :: Expr' -> Expr' -> Type
TyBool :: Type
TyList :: Type' -> Type
TyIterator :: Type' -> Type
TyArray :: Type' -> Expr' -> Type
data Literal
LitInt :: Integer -> Literal
LitBool :: Bool -> Literal
data Comprehension
Comprehension :: Expr' -> Maybe VarName -> Expr' -> Maybe Expr' -> Comprehension
data Expr
Lit :: Literal -> Expr
Var :: VarName -> Expr
Sub :: Expr' -> Expr' -> Expr
ListExt :: [Expr'] -> Expr
ListComp :: Comprehension -> Expr
IterComp :: Comprehension -> Expr
Call :: FunName -> [Expr'] -> Expr
Cond :: Expr' -> Expr' -> Expr' -> Expr
data ListShape
NoneShape :: ListShape
ListShape :: ListShape -> Expr' -> ListShape
data Sentence
If :: Expr' -> [Sentence'] -> [Sentence'] -> Sentence
For :: VarName -> Expr' -> [Sentence'] -> Sentence
Define :: VarName -> Maybe Type' -> Expr' -> Sentence
Declare :: VarName -> Maybe Type' -> ListShape -> Sentence
Assign :: VarName -> [Expr'] -> Expr' -> Sentence
Assert :: Expr' -> Sentence
Return :: Expr' -> Sentence
data ToplevelDecl
ConstDef :: VarName -> Maybe Type' -> Expr' -> ToplevelDecl
FunDef :: FunName -> [(VarName, Maybe Type')] -> Maybe Type' -> [Sentence'] -> ToplevelDecl
FromImport :: [Name] -> ToplevelDecl
newtype Program
Program :: [ToplevelDecl'] -> Program
[decls] :: Program -> [ToplevelDecl']
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Program
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Program
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Program
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Program
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.ToplevelDecl
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.ToplevelDecl
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.ToplevelDecl
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.ToplevelDecl
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Sentence
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Sentence
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Sentence
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Sentence
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.ListShape
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.ListShape
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.ListShape
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.ListShape
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Type
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Type
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Type
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Type
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Comprehension
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Comprehension
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Comprehension
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Comprehension
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Expr
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Expr
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Expr
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Expr
instance GHC.Read.Read Jikka.Language.Python.Parsed.Expr.Literal
instance GHC.Show.Show Jikka.Language.Python.Parsed.Expr.Literal
instance GHC.Classes.Ord Jikka.Language.Python.Parsed.Expr.Literal
instance GHC.Classes.Eq Jikka.Language.Python.Parsed.Expr.Literal

module Jikka.Deserializer.Python.Parser
run :: [WithPos Token] -> Either String Program

module Jikka.Deserializer.Python
run :: FilePath -> Text -> Either String Program

module Jikka.Language.Python.Typed.Stdlib
data ChurchType
TyInt :: ChurchType
TyBool :: ChurchType
TyList :: ChurchType -> ChurchType
TyIterator :: ChurchType -> ChurchType
TyVar :: TypeName -> ChurchType
data CurryType expr
ATyInt :: CurryType expr
ATyBool :: CurryType expr
ATyList :: CurryType expr -> CurryType expr
ATyNat :: CurryType expr
ATyInterval :: expr -> expr -> CurryType expr
ATyIterator :: CurryType expr -> CurryType expr
ATyArray :: CurryType expr -> expr -> CurryType expr
ATyVar :: TypeName -> CurryType expr
toChurchType :: CurryType expr -> ChurchType
toCurryType :: ChurchType -> CurryType expr
data Literal
LitInt :: Integer -> Literal
LitBool :: Bool -> Literal
data UnaryOp
Negate :: UnaryOp
Abs :: UnaryOp
Fact :: UnaryOp
Not :: UnaryOp
BitNot :: UnaryOp
Len :: ChurchType -> UnaryOp
Sum :: UnaryOp
Product :: UnaryOp
Min1 :: UnaryOp
Max1 :: UnaryOp
ArgMin :: UnaryOp
ArgMax :: UnaryOp
All :: UnaryOp
Any :: UnaryOp
Sorted :: ChurchType -> UnaryOp
List :: ChurchType -> UnaryOp
Reversed :: ChurchType -> UnaryOp
Range1 :: UnaryOp
data BinaryOp
Plus :: BinaryOp
Minus :: BinaryOp
Mult :: BinaryOp
FloorDiv :: BinaryOp
FloorMod :: BinaryOp
CeilDiv :: BinaryOp
CeilMod :: BinaryOp
Pow :: BinaryOp
Gcd :: BinaryOp
Lcm :: BinaryOp
Min :: BinaryOp
Max :: BinaryOp
Inv :: BinaryOp
Choose :: BinaryOp
Permute :: BinaryOp
MultiChoose :: BinaryOp
And :: BinaryOp
Or :: BinaryOp
Implies :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
BitLeftShift :: BinaryOp
BitRightShift :: BinaryOp
Range2 :: BinaryOp
LessThan :: BinaryOp
LessEqual :: BinaryOp
GreaterThan :: BinaryOp
GreaterEqual :: BinaryOp
Equal :: ChurchType -> BinaryOp
NotEqual :: ChurchType -> BinaryOp
data TernaryOp
Cond :: ChurchType -> TernaryOp
PowMod :: TernaryOp
Range3 :: TernaryOp
literalType :: Literal -> CurryType expr
unaryOpType :: UnaryOp -> (CurryType expr, CurryType expr)
binaryOpType :: BinaryOp -> (CurryType expr, CurryType expr, CurryType expr)
ternaryOpType :: TernaryOp -> (CurryType expr, CurryType expr, CurryType expr, CurryType expr)
instance GHC.Read.Read Jikka.Language.Python.Typed.Stdlib.TernaryOp
instance GHC.Show.Show Jikka.Language.Python.Typed.Stdlib.TernaryOp
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Stdlib.TernaryOp
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Stdlib.TernaryOp
instance GHC.Read.Read Jikka.Language.Python.Typed.Stdlib.BinaryOp
instance GHC.Show.Show Jikka.Language.Python.Typed.Stdlib.BinaryOp
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Stdlib.BinaryOp
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Stdlib.BinaryOp
instance GHC.Read.Read Jikka.Language.Python.Typed.Stdlib.UnaryOp
instance GHC.Show.Show Jikka.Language.Python.Typed.Stdlib.UnaryOp
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Stdlib.UnaryOp
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Stdlib.UnaryOp
instance GHC.Read.Read Jikka.Language.Python.Typed.Stdlib.Literal
instance GHC.Show.Show Jikka.Language.Python.Typed.Stdlib.Literal
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Stdlib.Literal
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Stdlib.Literal
instance GHC.Read.Read expr => GHC.Read.Read (Jikka.Language.Python.Typed.Stdlib.CurryType expr)
instance GHC.Show.Show expr => GHC.Show.Show (Jikka.Language.Python.Typed.Stdlib.CurryType expr)
instance GHC.Classes.Ord expr => GHC.Classes.Ord (Jikka.Language.Python.Typed.Stdlib.CurryType expr)
instance GHC.Classes.Eq expr => GHC.Classes.Eq (Jikka.Language.Python.Typed.Stdlib.CurryType expr)
instance GHC.Read.Read Jikka.Language.Python.Typed.Stdlib.ChurchType
instance GHC.Show.Show Jikka.Language.Python.Typed.Stdlib.ChurchType
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Stdlib.ChurchType
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Stdlib.ChurchType

module Jikka.Language.Python.Typed.Expr
type Type = CurryType Expr
data Comprehension
Comprehension :: Type -> Expr -> VarName -> Type -> Expr -> Maybe Expr -> Comprehension
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr
UnOp :: UnaryOp -> Expr -> Expr
BinOp :: BinaryOp -> Expr -> Expr -> Expr
TerOp :: TernaryOp -> Expr -> Expr -> Expr -> Expr
Sub :: Type -> Expr -> Expr -> Expr
ListExt :: Type -> [Expr] -> Expr
ListComp :: Comprehension -> Expr
IterComp :: Comprehension -> Expr
Call :: FunName -> [Expr] -> Expr
data Sentence
If :: Expr -> [Sentence] -> [Sentence] -> Sentence
For :: VarName -> Type -> Expr -> [Sentence] -> Sentence
Declare :: VarName -> Type -> [Expr] -> Sentence
Assign :: VarName -> [Expr] -> Expr -> Sentence
Define :: VarName -> Type -> Expr -> Sentence
Assert :: Expr -> Sentence
Return :: Expr -> Sentence
data ToplevelDecl
ConstDef :: VarName -> Type -> Expr -> ToplevelDecl
FunDef :: FunName -> [(VarName, Type)] -> Type -> [Sentence] -> ToplevelDecl
newtype Program
Program :: [ToplevelDecl] -> Program
[decls] :: Program -> [ToplevelDecl]
instance GHC.Read.Read Jikka.Language.Python.Typed.Expr.Program
instance GHC.Show.Show Jikka.Language.Python.Typed.Expr.Program
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Expr.Program
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Expr.Program
instance GHC.Read.Read Jikka.Language.Python.Typed.Expr.ToplevelDecl
instance GHC.Show.Show Jikka.Language.Python.Typed.Expr.ToplevelDecl
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Expr.ToplevelDecl
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Expr.ToplevelDecl
instance GHC.Read.Read Jikka.Language.Python.Typed.Expr.Sentence
instance GHC.Show.Show Jikka.Language.Python.Typed.Expr.Sentence
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Expr.Sentence
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Expr.Sentence
instance GHC.Read.Read Jikka.Language.Python.Typed.Expr.Comprehension
instance GHC.Show.Show Jikka.Language.Python.Typed.Expr.Comprehension
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Expr.Comprehension
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Expr.Comprehension
instance GHC.Read.Read Jikka.Language.Python.Typed.Expr.Expr
instance GHC.Show.Show Jikka.Language.Python.Typed.Expr.Expr
instance GHC.Classes.Ord Jikka.Language.Python.Typed.Expr.Expr
instance GHC.Classes.Eq Jikka.Language.Python.Typed.Expr.Expr

module Jikka.Language.Python.Parsed.Stdlib
unaryOps :: Map FunName UnaryOp
genericUnaryOps :: Map FunName (ChurchType -> UnaryOp)
binaryOps :: Map FunName BinaryOp
genericBinaryOps :: Map FunName (ChurchType -> BinaryOp)
ternaryOps :: Map FunName TernaryOp
operatorNames :: Set FunName

module Jikka.Converter.Python.Alpha
run :: Program -> Either String Program
instance GHC.Read.Read Jikka.Converter.Python.Alpha.AlphaState
instance GHC.Show.Show Jikka.Converter.Python.Alpha.AlphaState
instance GHC.Classes.Ord Jikka.Converter.Python.Alpha.AlphaState
instance GHC.Classes.Eq Jikka.Converter.Python.Alpha.AlphaState

module Jikka.Converter.Python.TypeInfer
run :: Program -> Either String Program

module Jikka.Converter.Python.ToCore
run :: Program -> Either String Program

module Jikka.Converter.Python.FromParsed
run :: Program -> Either String Program
instance GHC.Read.Read Jikka.Converter.Python.FromParsed.ConvState
instance GHC.Show.Show Jikka.Converter.Python.FromParsed.ConvState
instance GHC.Classes.Ord Jikka.Converter.Python.FromParsed.ConvState
instance GHC.Classes.Eq Jikka.Converter.Python.FromParsed.ConvState

module Jikka.Language.Python.Typed.TypeInfer
data TypeEnv
TypeEnv :: [(FunName, ([Type], Type))] -> [(VarName, Type)] -> TypeEnv
[funenv] :: TypeEnv -> [(FunName, ([Type], Type))]
[varenv] :: TypeEnv -> [(VarName, Type)]
emptyTypeEnv :: TypeEnv
infer' :: TypeEnv -> Expr -> Either String Type

-- | <a>infer</a> extracts the type of the given expr, under the assumption
--   that the expr is correctly typed.
infer :: TypeEnv -> Expr -> Type
check' :: TypeEnv -> Expr -> Either String Type

-- | <a>check</a> calculates the type of the given expr, with strict
--   checking about their Church-style types. This function says nothing
--   about Curry-style types.
check :: TypeEnv -> Expr -> Either String ChurchType
instance GHC.Read.Read Jikka.Language.Python.Typed.TypeInfer.TypeEnv
instance GHC.Show.Show Jikka.Language.Python.Typed.TypeInfer.TypeEnv
instance GHC.Classes.Ord Jikka.Language.Python.Typed.TypeInfer.TypeEnv
instance GHC.Classes.Eq Jikka.Language.Python.Typed.TypeInfer.TypeEnv

module Jikka.Serializer.AutoIndent
indent :: String
dedent :: String
makeIndentFromMarkers :: Int -> [String] -> [String]
makeIndentFromBraces :: Int -> [String] -> [String]
insertIndentDedentFromBraces :: [String] -> [String]


-- | <a>CPlusPlus</a> module converts the AST for C++ to the plain source
--   code.
module Jikka.Serializer.CPlusPlus
run :: Program -> Either String Text
run' :: Program -> String
instance GHC.Read.Read Jikka.Serializer.CPlusPlus.Assoc
instance GHC.Show.Show Jikka.Serializer.CPlusPlus.Assoc
instance GHC.Classes.Ord Jikka.Serializer.CPlusPlus.Assoc
instance GHC.Classes.Eq Jikka.Serializer.CPlusPlus.Assoc
instance GHC.Read.Read Jikka.Serializer.CPlusPlus.Prec
instance GHC.Show.Show Jikka.Serializer.CPlusPlus.Prec
instance GHC.Classes.Ord Jikka.Serializer.CPlusPlus.Prec
instance GHC.Classes.Eq Jikka.Serializer.CPlusPlus.Prec

module Jikka.Serializer.Core
run :: Program -> Either String Text
run' :: Program -> String
instance GHC.Read.Read Jikka.Serializer.Core.Builtin'
instance GHC.Show.Show Jikka.Serializer.Core.Builtin'
instance GHC.Classes.Ord Jikka.Serializer.Core.Builtin'
instance GHC.Classes.Eq Jikka.Serializer.Core.Builtin'

module Jikka.Serializer.Python
run :: Program -> Either String Text
run' :: Program -> String

module Jikka.Serializer.Show
run :: Show program => program -> Either String Text

module Jikka.Subcommand.Convert
run :: FilePath -> Text -> Either String Text

module Jikka.Subcommand.Debug
run :: FilePath -> ExceptT String IO ()

module Jikka.Subcommand.Execute
run :: FilePath -> ExceptT String IO ()

module Jikka.Main
data Flag
Help :: Flag
Verbose :: Flag
Version :: Flag
newtype Options
Options :: Bool -> Options
[verbose] :: Options -> Bool
defaultOptions :: Options
header :: String -> String
options :: [OptDescr Flag]
main :: String -> [String] -> IO ExitCode
parseFlags :: String -> [Flag] -> Either String Options
runSubcommand :: String -> Options -> FilePath -> ExceptT String IO ()
instance GHC.Read.Read Jikka.Main.Flag
instance GHC.Show.Show Jikka.Main.Flag
instance GHC.Classes.Ord Jikka.Main.Flag
instance GHC.Classes.Eq Jikka.Main.Flag
